# スペック駆動開発におけるマルチエージェント協調アーキテクチャに関する包括的研究報告書

## 1. 序論：エージェント・スウォームによるソフトウェア工学のパラダイムシフト

ソフトウェアエンジニアリングの歴史は、抽象化レベルの向上の歴史であると言えます。アセンブリ言語から高水準言語へ、そして宣言型プログラミングへと進化してきたこの流れは、現在「AI エージェントによる自律的実装」という新たなフェーズに突入しようとしています。

本報告書では、スペック駆動開発（Spec-Driven Development: SDD）において、特性の異なる 3 つの AI エージェント――Anthropic の Claude Code、OpenAI エコシステムの系譜を継ぐ Codex (GPT-OSS)、そして Google の Gemini 3 Pro――を並列稼働させ、その多様な出力を統合することで、単一モデルの限界を超えた「最良のコード」を生成するためのアーキテクチャを提案します。

特に、従来のバージョン管理システム（VCS）である Git が抱える並行性の制約を克服するために、次世代 VCS である Jujutsu (jj) を基盤インフラとして採用します。Jujutsu の「ファーストクラス・コンフリクト（First-Class Conflicts）」という概念は、競合を「エラー」ではなく「合成のためのデータ構造」として扱うことを可能にし、人間が介在しない完全自律型のマルチエージェント・ワークフローを実現する鍵となります。

本稿では、各エージェントの特性分析、Jujutsu によるロックフリーな並行処理の実装、そして競合解決を通じたコード合成の具体的なワークフローについて、詳細に論じます。

## 2. 理論的枠組み：認識論的多様性とコード品質

### 2.1 単一モデル依存のリスクと「モデル崩壊」

現在の AI コーディング支援は、主に「ペアプログラミング」モデル、すなわち人間と単一の AI アシスタントとの対話に基づいています。しかし、このアプローチには「トンネルビジョン（視野狭窄）」のリスクが伴います。特定のモデル（例えば GPT-4o）は、特定のアーキテクチャパターンやライブラリに対して強いバイアスを持っており、一度誤った設計方針（局所最適解）に陥ると、そこから脱却することが困難です。また、単一モデルがスペックの曖昧性を誤解釈した場合、実装全体が破綻する脆弱性を抱えています。

### 2.2 アンサンブル・エンジニアリングの提唱

これに対し、本研究が提唱する「アンサンブル・エンジニアリング」は、統計学における「大数の法則」と認識論的な「多様性」をソフトウェア開発に応用するものです。Claude、GPT、Gemini という異なる学習データとアーキテクチャを持つモデル群は、同じスペックに対して異なるアプローチ（実装の多様性）を提示します。

| エージェント    | 役割定義                   | 特性 (Strength)                                                                              | 弱点 (Weakness)                                                                  |
| --------------- | -------------------------- | -------------------------------------------------------------------------------------------- | -------------------------------------------------------------------------------- |
| Claude Code     | The Architect (設計者)     | 安全性、可読性、大規模な文脈保持、Unix 哲学に基づく CLI 操作                                 | 冗長なコード記述、過剰な防御的プログラミングの傾向                               |
| Codex (GPT-OSS) | The Optimizer (最適化担当) | アルゴリズム効率、標準ライブラリの熟知、ローカル実行による低レイテンシ                       | 最新フレームワークへの知識不足（カットオフによる）、コンテキストウィンドウの制約 |
| Gemini 3 Pro    | The Innovator (革新者)     | 超長大なコンテキスト（2M+）、マルチモーダル理解、"Vibe Coding"によるラピッドプロトタイピング | 存在しない API の幻覚（Hallucination）、不安定な出力フォーマット                 |

この 3 者の出力を統合することで、Claude の堅牢性、Codex の効率性、Gemini の革新性を兼ね備えたコードを合成することが理論的に可能となります。しかし、これを実現するためには、3 者が同時に同じファイルセットを操作するという「分散システム上の合意形成問題」を解決しなければなりません。

## 3. インフラストラクチャ層：Jujutsu (jj) による並行性の解決

Git を用いた従来のワークフローでは、複数のエージェントが同時にコミットを行おうとすると、インデックス（ステージングエリア）のロック競合や、マージ時のコンフリクトによる処理停止（Abort）が発生します。これは自律的な自動化を阻害する最大の要因です。

Jujutsu (jj) は、この問題を根本的なデータモデルのレベルで解決します。

### 3.1 ファーストクラス・コンフリクトの数学的意味

Git においてコンフリクトは「マージの失敗」を意味しますが、Jujutsu においてコンフリクトは「コミット内に記録される成功した状態」です。Jujutsu のコミットは単一のツリーではなく、ツリーの「項」として表現されます。コンフリクトが発生した場合、Jujutsu はその状態を以下のような論理的表現として記録します。

```
State = Base + (Side_A - Base) + (Side_B - Base) + (Side_C - Base)
```

この数式が意味するのは、コンフリクト状態そのものがバージョン管理システムの中で永続化可能であり、リベースやマージ、さらにはプッシュさえも可能であるということです。これにより、オーケストレーターは「エージェント間の意見の不一致」を解決することなく、一旦すべてをリポジトリに保存し、後続のプロセス（Judgement Phase）へと先送りすることが可能になります。

### 3.2 操作ログによるロックフリー並行性

Jujutsu は、リポジトリに対するすべての変更操作を「操作ログ（Operation Log）」として追記型で記録します。これにより、分散ファイルシステム上や複数のプロセス間であっても、ロックファイルを用いた排他制御を行うことなく、安全に並行操作を行うことができます。

本アーキテクチャでは、この特性を利用して、3 つのエージェントがそれぞれの「ワークスペース」で並列に作業を行い、その結果を中央のリポジトリデータベースに非同期で書き込む構成をとります。

### 3.3 ワークスペース vs ワークツリー

Git のワークツリー（worktree）に相当する機能として、Jujutsu は「ワークスペース（Workspace）」を提供しています。しかし、Jujutsu のワークスペースは「現在の作業コピーそのものがコミットである」という概念に基づいており、ブランチ名（Ref）を必須としません（匿名ブランチ）。これにより、エージェントは「feature-branch-claude」のような名前空間の管理を気にする必要がなく、単に「現在の作業状態」に対して変更を積み重ねていくことができ、オーケストレーターの管理ロジックを大幅に簡素化できます。

## 4. アーキテクチャ設計：トライデント・トポロジー

本システムは、中央の管理スクリプト（Orchestrator）が 3 つの独立したサブプロセスを制御し、Jujutsu リポジトリを介してデータを同期する「トライデント（三叉の槍）」型のトポロジーを採用します。

### 4.1 ディレクトリ構成とコンポーネント

システムの物理的な配置は以下の通りです。すべてのワークスペースは単一の `.jj` ディレクトリ（オブジェクトストレージ）を共有します。

```
/project-root
  ├── .jj/                    # 共有リポジトリデータベース（Gitバックエンド互換）
  ├── spec.md                 # 単一の真実となる仕様書（Source of Truth）
  ├── orchestrator.py         # 統合制御スクリプト
  ├── ws-main/                # 統合・レビュー用ワークスペース（ユーザー用）
  ├── ws-claude/              # Claude Code 専用サンドボックス
  ├── ws-codex/               # Codex (GPT-OSS) 専用サンドボックス
  └── ws-gemini/              # Gemini 3 Pro 専用サンドボックス
```

### 4.2 エージェント実行環境の構成

各エージェントは、それぞれの CLI ツールを介して操作されます。

- **Claude Code CLI**: `claude` コマンドを使用。`--print` フラグによる非対話モードと `--dangerously-skip-permissions` フラグによる自律実行を有効化します。
- **Codex (GPT-OSS) Interface**: OpenAI 互換のエンドポイントを持つ CLI ツール（例：aider またはカスタムラッパー）を使用します。ここでは、オープンウェイトモデルである `gpt-oss-120b` をローカルまたはプライベートクラウドでホストし、API 経由で叩く構成を想定します。
- **Gemini CLI**: `gemini` コマンドを使用。`gemini-3-pro` モデルを指定し、非対話モードで実行します。

## 5. 実装ワークフロー詳細

ワークフローは大きく 4 つのフェーズに分かれます。

### Phase 1: 初期化と仕様注入 (Initialization & Spec Injection)

プロジェクトの開始点において、最も重要なのは「仕様（Spec）」の明確化です。

1. **リポジトリの初期化**: `ws-main` において `jj git init` を実行し、Git バックエンドを持つ Jujutsu リポジトリを作成します。
2. **仕様書のコミット**: `spec.md` を作成し、コミットします。このコミットハッシュ（例: `rev-0`）が、全エージェントの共通の祖先（Common Ancestor）となります。
3. **ワークスペースの複製**: `jj workspace add` コマンドを使用し、`rev-0` をベースとした 3 つのワークスペースを作成します。

```bash
# Orchestratorによる初期化シーケンス
jj git init .
jj new -m "Initial commit: Add Specification"
# spec.md の配置
jj commit
BASE_REV=$(jj log -T "change_id" --no-graph --limit 1)

# 各エージェント用ワークスペースの作成
jj workspace add ../ws-claude $BASE_REV
jj workspace add ../ws-codex $BASE_REV
jj workspace add ../ws-gemini $BASE_REV
```

### Phase 2: 並列実装 (Parallel Divergence)

オーケストレーターは 3 つのサブプロセスを起動し、各ワークスペースでエージェントを実行させます。ここでは、各エージェントの強みを最大化するためのプロンプトエンジニアリングが重要となります。

#### 2.1 Claude Code の実行 (ws-claude)

Claude には「アーキテクト」としての役割を与えます。詳細な設計ドキュメントを参照させ、堅牢な構造を作らせます。

```bash
cd ../ws-claude
jj new -m "feat(claude): Implementation based on spec"
# Claude Code CLI の実行
claude -p "spec.mdの内容に基づき、src/ ディレクトリに実装コードを生成せよ。エラーハンドリングと型定義を厳密に行うこと。" \
       --allowedTools "Bash,Read,Write" \
       --dangerously-skip-permissions
```

**注記**: Claude Code の `--dangerously-skip-permissions` は、ファイル書き込みごとのユーザー承認をスキップするために不可欠です。

#### 2.2 Codex (GPT-OSS) の実行 (ws-codex)

Codex には「最適化」を重視させます。`gpt-oss-120b` などのオープンモデルを使用する場合、具体的なアルゴリズムの実装や、ライブラリ依存の少ないピュアな実装を指示します。

```bash
cd ../ws-codex
jj new -m "feat(codex): Implementation based on spec"
# カスタムCLIラッパー経由でGPT-OSSを実行
llm-cli --model gpt-oss-120b \
        --system "あなたはパフォーマンス・オプティマイザーです。spec.mdを実装し、計算量とメモリ効率を最優先してください。" \
        --output-dir src/
```

#### 2.3 Gemini 3 Pro の実行 (ws-gemini)

Gemini には「革新性」を求めます。長大なコンテキストウィンドウを活かし、関連する外部ドキュメントや大規模なライブラリのリファレンスを同時に読み込ませることが可能です。

```bash
cd ../ws-gemini
jj new -m "feat(gemini): Implementation based on spec"
# Gemini CLI の実行
gemini -p "spec.mdを実装せよ。最新のライブラリ機能を活用し、モダンで簡潔なコードを目指せ。" \
       --model gemini-3-pro
```

### Phase 3: 収束とコンフリクトの顕在化 (Convergence & Conflict Materialization)

3 つのエージェントが作業を完了すると、それぞれが独立したコミット（リーフノード）を作成した状態になります。オーケストレーターはこれらを `ws-main` に集約します。

ここで Jujutsu の真価が発揮されます。通常の Git であれば `git merge` を 3 回行う必要があり、その都度発生するコンフリクトを手動で解決しなければ先に進めません。しかし `jj` では、3 つの変更 ID（Change ID）を指定して一度にマージコミットを作成することができます。

```bash
# 各ワークスペースの最新Change IDを取得
ID_CLAUDE=$(jj log -w ../ws-claude -T "change_id" --no-graph --limit 1)
ID_CODEX=$(jj log -w ../ws-codex -T "change_id" --no-graph --limit 1)
ID_GEMINI=$(jj log -w ../ws-gemini -T "change_id" --no-graph --limit 1)

cd ../ws-main
# 3-way (実際には4-way: Base + 3 Agents) マージの実行
jj new $ID_CLAUDE $ID_CODEX $ID_GEMINI -m "merge: Integrate agent swarm"
```

この操作により、`ws-main` には「コンフリクトを含んだコミット」が作成されます。ファイルシステム上には、Jujutsu のコンフリクトマーカーが書き込まれます。

### Phase 4: AI による調停と合成 (Synthesis by The Judge)

最後に、発生したコンフリクトを解決し、最終的なコードを生成するための「裁判官（The Judge）」エージェントを起動します。この役割には、最も推論能力が高いモデル（例：OpenAI o1、または Gemini 3 Pro の Reasoning モード）を割り当てます。

#### 4.1 コンフリクトマーカーの解析

Jujutsu の `snapshot` スタイルのコンフリクトマーカーを使用することで、各エージェントの出力を明確に区別できます。

```python
<<<<<<< Conflict 1 of 1
%%%%%%% Changes from base to Side #1 (Claude)
def process_data(data: List[int]) -> int:
    """Claudeの堅牢な実装"""
    if not data: return 0
   ...
+++++++ Contents of Side #2 (Codex)
def process_data(d):
    # Codexの高速な実装
    return sum(x*2 for x in d)
+++++++ Contents of Side #3 (Gemini)
def process_data(data):
    # Geminiのモダンな実装
    import numpy as np
   ...
>>>>>>> Conflict 1 of 1 ends
```

#### 4.2 裁判官エージェントへのプロンプト

オーケストレーターは、コンフリクトが発生しているファイルを検出し（`jj resolve --list`）、その内容を裁判官エージェントに渡します。

**System Prompt for The Judge:**

```
あなたはシニア・ソフトウェアアーキテクトです。現在、3人のエンジニア（Claude, Codex, Gemini）が
同じ仕様書に基づいて異なる実装を行いました。以下のファイルには、彼らの実装がコンフリクト
マーカーで区切られて含まれています。

- Side #1 (Claude): 安全性と可読性を重視しています。
- Side #2 (Codex): パフォーマンスを重視しています。
- Side #3 (Gemini): 革新性を重視していますが、幻覚の可能性があります。

あなたの任務は、これらを統合し、仕様を満たす『最良のコード』を一つ作成することです。
コンフリクトマーカーをすべて削除し、最終的なコードのみを出力してください。
```

#### 4.3 解決の適用

裁判官エージェントが出力したコードでファイルを上書きし、コンフリクトを解消します。その後、テストを実行し、問題がなければコミットを確定（squash）します。

```bash
# コンフリクト解消後の確定
jj resolve --list # 空であることを確認
jj squash
```

## 6. 技術的優位性と比較分析

### 6.1 Google Antigravity との比較

Google が発表した「Antigravity」は、エージェントファーストの開発プラットフォームであり、「Artifacts（アーティファクト）」と呼ばれる検証可能な成果物を生成することで信頼性を担保します。Antigravity は統合された GUI 環境（IDE）を提供するのに対し、本提案のアーキテクチャは CLI ベースのヘッドレス・オーケストレーションに焦点を当てています。

| 特徴   | Google Antigravity                | 提案アーキテクチャ (Jujutsu + Swarm)     |
| ------ | --------------------------------- | ---------------------------------------- |
| 環境   | 統合 IDE (VS Code fork)           | CLI / ヘッドレス・スクリプト             |
| モデル | Gemini 3 Pro / Claude (選択式)    | 任意のモデルを混在可能 (Model Agnostic)  |
| 並行性 | Agent Manager による非同期実行    | Jujutsu による物理的に分離された並行実行 |
| 成果物 | GUI 上の Artifacts (リスト、計画) | Git 互換のコミット履歴と操作ログ         |
| 制御   | Human-in-the-loop (UI ベース)     | Human-on-the-loop (設定ベース)           |

本アーキテクチャは、特定のベンダー（Google）にロックインされることなく、OpenAI や Anthropic の最新モデルを柔軟に組み合わせることができる点で優位性があります。また、Jujutsu の採用により、どのような複雑なマージ状態であっても、操作ログを通じて過去の状態に瞬時に戻すことができる「タイムトラベル・デバッグ」が可能であり、これは試行錯誤を繰り返す AI 開発において強力な安全網となります。

### 6.2 幻覚（Hallucination）の相互監視

3 つのモデルを並列させる最大の利点は、幻覚の検出です。例えば、Gemini があるライブラリの架空のメソッドを呼び出したとしても、Claude と Codex が標準的なメソッドを使用していれば、統合フェーズ（裁判官エージェント）において「多数決」あるいは「論理的整合性チェック」により、Gemini の誤りが棄却される可能性が高まります。これは「敵対的」な検証プロセスとして機能し、コードの信頼性を向上させます。

## 7. 結論と実装へのロードマップ

本報告書で設計したアーキテクチャは、単なるツールの組み合わせではなく、AI エージェントを「執筆者」から「協調的な開発チーム」へと昇華させるための構造的アプローチです。Jujutsu (jj) のファーストクラス・コンフリクト機能は、これまで自動化のボトルネックとなっていた「マージの壁」を取り払い、複数の知性が同時にコードベースを進化させることを可能にします。

### 実装に向けた推奨ステップ

1. **パイロット運用**: 単純な Python スクリプトの仕様を用い、3 つのエージェントワークスペースの同期とマージが正常に動作するかを検証する。
2. **Jujutsu 設定の最適化**: コンフリクトマーカーのスタイルを `snapshot` に固定し、裁判官エージェントがパースしやすい形式を確立する。
3. **裁判官プロンプトの洗練**: 単なる統合ではなく、各エージェントの長所（Claude の型安全性、Codex の速度など）を明示的に採り入れるよう、システムプロンプトをチューニングする。
4. **CI パイプラインへの統合**: 仕様書の変更をトリガーとして、自動的にこのワークフローが走り、人間は最終的なプルリクエスト（裁判官による統合済みコード）のみをレビューする体制を構築する。

このアーキテクチャは、ソフトウェア開発における「人間」の役割を、コードの書き手から、エージェント・スウォームの指揮者（Orchestrator）へと変革させるものです。
