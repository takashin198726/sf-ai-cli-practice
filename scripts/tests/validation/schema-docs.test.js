/**
 * Validation tests for schema documentation markdown files
 * Tests the generated markdown documentation for completeness and accuracy
 */

const fs = require('fs');
const path = require('path');

describe('Schema Documentation Markdown Validation', () => {
  const docsPath = path.join(__dirname, '../../../docs/schema');

  describe('Documentation Structure', () => {
    test('docs/schema directory should exist', () => {
      expect(fs.existsSync(docsPath)).toBe(true);
      expect(fs.statSync(docsPath).isDirectory()).toBe(true);
    });

    test('should have README.md', () => {
      const readmePath = path.join(docsPath, 'README.md');
      expect(fs.existsSync(readmePath)).toBe(true);
    });

    test('should have Account.md', () => {
      const accountPath = path.join(docsPath, 'Account.md');
      expect(fs.existsSync(accountPath)).toBe(true);
    });

    test('should have schema.json', () => {
      const schemaJsonPath = path.join(docsPath, 'schema.json');
      expect(fs.existsSync(schemaJsonPath)).toBe(true);
    });
  });

  describe('README.md Validation', () => {
    const readmePath = path.join(docsPath, 'README.md');
    let readmeContent;

    beforeAll(() => {
      readmeContent = fs.readFileSync(readmePath, 'utf8');
    });

    test('should not be empty', () => {
      expect(readmeContent.trim().length).toBeGreaterThan(0);
    });

    test('should have a header', () => {
      expect(readmeContent).toMatch(/^#\s+/m);
    });

    test('should have Tables section', () => {
      expect(readmeContent).toMatch(/##\s+Tables/);
    });

    test('should have a table listing objects', () => {
      expect(readmeContent).toContain('| Name | Columns | Comment | Type |');
      expect(readmeContent).toContain('| ---- | ------- | ------- | ---- |');
    });

    test('should reference Account table', () => {
      expect(readmeContent).toMatch(/\[Account\]\(Account\.md\)/);
    });

    test('Account table should show 2 columns', () => {
      const accountRow = readmeContent.match(/\|\s*\[Account\]\(Account\.md\)\s*\|\s*(\d+)\s*\|/);
      expect(accountRow).toBeTruthy();
      if (accountRow) {
        expect(accountRow[1]).toBe('2');
      }
    });

    test('Account should be marked as Standard object', () => {
      expect(readmeContent).toMatch(/\|\s*\[Account\]\(Account\.md\)\s*\|\s*2\s*\|\s*\|\s*Standard object\s*\|/);
    });

    test('should have Relations section', () => {
      expect(readmeContent).toMatch(/##\s+Relations/);
    });

    test('should contain Mermaid ER diagram', () => {
      expect(readmeContent).toContain('```mermaid');
      expect(readmeContent).toContain('erDiagram');
      expect(readmeContent).toContain('```');
    });

    test('Mermaid diagram should include Account entity', () => {
      expect(readmeContent).toMatch(/"Account"\s*\{/);
    });

    test('should have tbls attribution footer', () => {
      expect(readmeContent).toContain('> Generated by [tbls](https://github.com/k1LoW/tbls)');
    });

    test('should use proper markdown formatting', () => {
      // Check for common markdown issues
      expect(readmeContent).not.toMatch(/\*\*\*\*/); // No quadruple asterisks
      expect(readmeContent).not.toMatch(/\[\]\(\)/); // No empty links
    });

    test('should have consistent line endings', () => {
      expect(readmeContent).not.toContain('\r\n'); // No Windows line endings
    });
  });

  describe('Account.md Validation', () => {
    const accountPath = path.join(docsPath, 'Account.md');
    let accountContent;

    beforeAll(() => {
      accountContent = fs.readFileSync(accountPath, 'utf8');
    });

    test('should not be empty', () => {
      expect(accountContent.trim().length).toBeGreaterThan(0);
    });

    test('should have Account as main header', () => {
      expect(accountContent).toMatch(/^#\s+Account/m);
    });

    test('should have Description section', () => {
      expect(accountContent).toMatch(/##\s+Description/);
    });

    test('should have Columns section', () => {
      expect(accountContent).toMatch(/##\s+Columns/);
    });

    test('should have columns table with proper headers', () => {
      expect(accountContent).toContain('| Name | Type | Default | Nullable | Children | Parents | Comment |');
      expect(accountContent).toContain('| ---- | ---- | ------- | -------- | -------- | ------- | ------- |');
    });

    test('should document Id column', () => {
      expect(accountContent).toMatch(/\|\s*Id\s*\|\s*Id\s*\|\s*\|\s*false\s*\|/);
    });

    test('should document Name column', () => {
      expect(accountContent).toMatch(/\|\s*Name\s*\|\s*Name\s*\|\s*\|\s*false\s*\|/);
    });

    test('Id column should have comment', () => {
      const idRow = accountContent.match(/\|\s*Id\s*\|[^|]*\|[^|]*\|[^|]*\|[^|]*\|[^|]*\|\s*([^|]+)\s*\|/);
      expect(idRow).toBeTruthy();
      if (idRow) {
        expect(idRow[1].trim()).toBe('Id');
      }
    });

    test('should have Constraints section', () => {
      expect(accountContent).toMatch(/##\s+Constraints/);
    });

    test('should have constraints table', () => {
      expect(accountContent).toContain('| Name | Type | Definition |');
      expect(accountContent).toContain('| ---- | ---- | ---------- |');
    });

    test('should document Primary Key constraint', () => {
      expect(accountContent).toMatch(/\|\s*Id\s*\|\s*Primary Key\s*\|\s*Primary Key\s*\|/);
    });

    test('should have Indexes section', () => {
      expect(accountContent).toMatch(/##\s+Indexes/);
    });

    test('should have indexes table', () => {
      expect(accountContent).toContain('| Name | Definition |');
      expect(accountContent).toContain('| ---- | ---------- |');
    });

    test('should document Id index', () => {
      expect(accountContent).toMatch(/\|\s*Id\s*\|\s*Primary Key\s*\|/);
    });

    test('should document Name index', () => {
      expect(accountContent).toMatch(/\|\s*Name\s*\|\s*Name\s*\|/);
    });

    test('should have Relations section', () => {
      expect(accountContent).toMatch(/##\s+Relations/);
    });

    test('should contain Mermaid ER diagram', () => {
      expect(accountContent).toContain('```mermaid');
      expect(accountContent).toContain('erDiagram');
      expect(accountContent).toContain('```');
    });

    test('Mermaid diagram should show Account fields', () => {
      expect(accountContent).toMatch(/"Account"\s*\{/);
      expect(accountContent).toContain('Id Id');
      expect(accountContent).toContain('Name Name');
    });

    test('should have tbls attribution footer', () => {
      expect(accountContent).toContain('> Generated by [tbls](https://github.com/k1LoW/tbls)');
    });

    test('should be properly structured with sections in order', () => {
      const sections = [
        accountContent.indexOf('# Account'),
        accountContent.indexOf('## Description'),
        accountContent.indexOf('## Columns'),
        accountContent.indexOf('## Constraints'),
        accountContent.indexOf('## Indexes'),
        accountContent.indexOf('## Relations')
      ];

      for (let i = 1; i < sections.length; i++) {
        expect(sections[i]).toBeGreaterThan(sections[i - 1]);
      }
    });
  });

  describe('Documentation Content Consistency', () => {
    let readmeContent;
    let accountContent;
    let schemaJson;

    beforeAll(() => {
      readmeContent = fs.readFileSync(path.join(docsPath, 'README.md'), 'utf8');
      accountContent = fs.readFileSync(path.join(docsPath, 'Account.md'), 'utf8');
      schemaJson = JSON.parse(fs.readFileSync(path.join(docsPath, 'schema.json'), 'utf8'));
    });

    test('README should link to all documented tables', () => {
      const tableCount = schemaJson.tables.length;
      schemaJson.tables.forEach(table => {
        expect(readmeContent).toMatch(new RegExp(`\\[${table.name}\\]\\(${table.name}\\.md\\)`));
      });
    });

    test('column count in README should match schema.json', () => {
      const accountTable = schemaJson.tables.find(t => t.name === 'Account');
      const columnCount = accountTable.columns.length;
      expect(readmeContent).toMatch(new RegExp(`\\[Account\\]\\(Account\\.md\\)\\s*\\|\\s*${columnCount}`));
    });

    test('Account.md should document all columns from schema.json', () => {
      const accountTable = schemaJson.tables.find(t => t.name === 'Account');
      accountTable.columns.forEach(column => {
        expect(accountContent).toMatch(new RegExp(`\\|\\s*${column.name}\\s*\\|`));
      });
    });

    test('Account.md should document all indexes from schema.json', () => {
      const accountTable = schemaJson.tables.find(t => t.name === 'Account');
      accountTable.indexes.forEach(index => {
        expect(accountContent).toMatch(new RegExp(`\\|\\s*${index.name}\\s*\\|`));
      });
    });

    test('Account.md should document all constraints from schema.json', () => {
      const accountTable = schemaJson.tables.find(t => t.name === 'Account');
      accountTable.constraints.forEach(constraint => {
        expect(accountContent).toMatch(new RegExp(`\\|\\s*${constraint.name}\\s*\\|`));
      });
    });
  });

  describe('Markdown Quality', () => {
    const files = ['README.md', 'Account.md'];

    files.forEach(file => {
      describe(`${file}`, () => {
        let content;

        beforeAll(() => {
          content = fs.readFileSync(path.join(docsPath, file), 'utf8');
        });

        test('should not have broken internal links', () => {
          const links = content.match(/\[([^\]]+)\]\(([^)]+)\)/g) || [];
          links.forEach(link => {
            const match = link.match(/\[([^\]]+)\]\(([^)]+)\)/);
            if (match && match[2] && !match[2].startsWith('http')) {
              const linkPath = path.join(docsPath, match[2]);
              expect(fs.existsSync(linkPath)).toBe(true);
            }
          });
        });

        test('should have proper table alignment', () => {
          const tables = content.match(/\|[^\n]+\|\n\|[-\s:|]+\|/g) || [];
          tables.forEach(table => {
            const [header, separator] = table.split('\n');
            const headerCols = header.split('|').filter(c => c.trim()).length;
            const separatorCols = separator.split('|').filter(c => c.trim()).length;
            expect(headerCols).toBe(separatorCols);
          });
        });

        test('should not have trailing spaces in lines', () => {
          const lines = content.split('\n');
          lines.forEach((line, index) => {
            if (line.length > 0 && index < lines.length - 1) {
              expect(line).not.toMatch(/\s$/);
            }
          });
        });

        test('should end with newline', () => {
          expect(content).toMatch(/\n$/);
        });

        test('should have consistent header levels', () => {
          const headers = content.match(/^#+\s+.+$/gm) || [];
          headers.forEach(header => {
            // Headers should use proper markdown (space after #)
            expect(header).toMatch(/^#+\s+\S/);
          });
        });
      });
    });
  });
});